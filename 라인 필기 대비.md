# 라인 필기 대비

## 알고리즘

### 버블 소트

* 인접한 두 개의 데이터를 비교해가면서 정렬을 진행하는 방식
* 빅 오 엔 제곱

### 선택 정렬(셀렉션 소트)

* 순회하면서 젤 작은 값(큰 값)의 인덱스 찾고 맨 앞(뒤)으로 보냄
* 빅 오 엔 제곱

### 삽입 정렬

* 두 번째 값부터 앞의 값과 비교 시작
* temp가 앞의 값보다 작다면 앞의 값은 뒤로 밀어준다.
* 크면 그 자리에 넣는다.
* 빅 오 엔 제곱

### 머지 소트

* 나눠지지 않을 때까지 반으로 나눈 후 합칠 때, 큰 건 뒤로 작은 건 앞으로 합친다.
* 빅오 엔 로그 엔

### 힙 소트

* 힙은 맥스힙 민 힙 있는데 맥스힙은 부모 노드가 자식 노드보다 큰 것
* 힙의 삭제 연산(루트 값을 꺼내고 힙의 마지막 노드를 루트에 삽입)을 계속해서 진행해서 정렬 마무리
* 빅오 엔 로그 엔

### 퀵 소트

* 배열 중 숫자 하나를 피벗으로 설정하고 맨 끝으로 보낸다.
* 왼쪽과 오른쪽 인덱스에서 하나씩 줄여가며 피벗과 비교
* 왼쪽 거가 피벗보다 작으면 다음으로 넘어가고 크면 가만히 있는다.
* 오른쪽 거가 피벗보다 크면 다음으로 넘어가고 작으면 가만히 있는다.
* 왼쪽거가 크고 오른쪽거가 크면 바꿔주고 둘다 다음으로 넘어간다.
* 왼쪽과 오른쪽이 만난 수와 피벗을 바꿔준다.
* 피벗의 왼쪽과 오른쪽에 대해서 다시 퀵소트 진행
* 최악은 빅오 엔제곱 평균 빅오 엔로그엔

### 카운팅 소트

* 좁은 범위에 존재하는 데이터 정렬할 때 좋음
* 수 중 최대값의 크기만큼 배열 생성하고 한바퀴 돌면서 해당 수가 있으면 배열의 해당 수 인덱스에 카운트를 올려준다.
* 그리고 마지막에 해당 수의 카운트만큼 적어준다.
* 공간복잡도 최대값의 크기, 시간복잡도 빅오 엔

### 래딕스 소트(기수 정렬)

* 빅 오 엔
* 가장 작은 자리수부터 비교 lsd 큰 자리수 비교 msd



## 데이터베이스

### SQL

#### create

* create schema 스키마 이름

* create table 테이블 이름(칼럼명 datatype not null)

  primary key()

  foreign key()

#### alter

* alter table 테이블 이름 add 속성이름 data type, alter 속성 이름, drop 속성 이름 

#### drop

* drop schema 스키마 이름, domain 도메인 이름, table 테이블 이름 등등

#### select

* select 속성명 from 테이블명 where 조건 group by  속성명 having (그룹함수 count, max, min, sum, avg)  조건 (그룹 조건) order by 속성명

#### insert

* insert into 테이블명(속성명) values (데이터)

#### delete

* delete from 테이블명 where 조건

#### update

* update 테이블명 set 속성명 = 데이터 where 조건

### 특징

#### 독립성

* 물리적 독립성 : 데이터 베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
* 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.

#### 무결성

* 잘못된 데이터가 발생하는 경우의 수를 방지, 데이터 유효성 검사를 통해 무결성 구현

#### 보안성

* 인가된 사용자들만 자원에 접근하도록 설정

#### 일관성

* 연관된 정보를 논리적인 구조로 관리, 하나의 데이터만 변경했을 때 데이터의 불일치성을 배제

#### 중복 최소화

* 데이터를 통합해서 관리함으로써 자료의 중복과 데이터 중복성 문제 해결

#### 성능

* 랜덤 I/O 작업을 순차 I/O로 바꿔서 실행하기 위해 데이터베이스 쿼리 튜닝을 한다.

### 인덱스

* 항상 정렬된 상태를 유지하므로, 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 느리다. 인덱스는 데이터의 저장 성능을 희생하고 읽기 속도를 높이는 기능이다.

#### 인덱스 자료구조

* B+- 트리 사용

### 정규화

#### 생긴 배경

* 여러 엔티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되고 저장 공간이 낭비됨
* 중복 정보로 인한 갱신 이상 발생
* 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 무엇이 정확한지 알수 없게 된다.

##### 갱신 이상

* 삽입 이상
  * 원하지 않는 자료가 삽입 or 삽입하는데 자료가 부족해 삽입이 되지 않아 발생
* 삭제 이상
  * 하나의 자료만 삭제하고 싶지만, 자료가 포함된 튜플 전체가 삭제됨
* 수정 이상
  * 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지고 일관성이 없어짐

#### 정규화란?

* 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화함
* 나쁜 릴레이션의 어트리뷰트들을 나눠서 좋은 작은 릴레이션으로 분해
* 나쁜 릴레이션
  * 엔티티를 구성하고 있는 애트리뷰트 간에 함수적 종속성 판단
  * 판단된 함수적 종속성은 좋은 릴레이션 설계의 정형적 기준으로 사용
* 함수적 종속성
  * 어트리뷰트 데이터들의 의미와 어트리뷰트들 간의 상호 관계로부터 유도되는 제약조건
  * X와 Y를 임의의 어트리뷰트 집합이라고 하면, X의 값이 Y의 값을 유일하게 결정한다면 X는 Y를 함수적으로 결정한다.
  * 함수적 종속성은 실세계에 존재하는 어트리뷰트들 사이의 제약조건으로 유도

#### 정규화의 장점

* 데이터베이스 변경 시 이상 현상 제거
* 데이터베이스 구조 확장 시 재 디자인 최소화
* 사용자에게 데이터 모델을 더욱 의미있게 제공

#### 정규화의 단점

* 릴레이션의 분해로 인해 릴레이션 간 연산이 많아진다. 이로 인해 쿼리의 응답시간이 느려질 수 있다.

### 트랜잭션

#### 정의

* 작업의 완전성을 보장해주는 것
* 논리적인 작업 셋을 모두 완벽하게 처리하거나 처리하지 모살 경우 원상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만드는 기능

#### 트랜잭션과 락

* 락은 동시성을 제어하기 위한 기능 트랜잭션은 데이터의 정합성을 보장하기 위한 기능
* 락은 동시에 동일한 자원을 요청할 경우 먼저 요청한 순서로 변경하게 해줌
* 트랜잭션은 하나의 논리적인 작업 셋 중 몇 개의 쿼리든 100% 적용하거나 아예 안하게 한다. 에러가 있을 경우 다 적용하지 않는다. 커밋이 돼야 데이터베이스에 적용된다.

#### 교착 상태

* 복수의 트랜잭션을 사용할 때 발생

* 두 개 이상의 트랜잭션이 특정 자원의 잠금을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태(데드락)

  ![1553242917646](assets/1553242917646.png)

* 빈도를 낮추는 방법

  * 트랜잭션을 자주 커밋한다
  * 정해진 순서로 테이블 접근
  * 읽기 잠금 획득의 사용을 피한다.(SELECT ~ FOR UPDATE)



## 네트워크

### TCP

#### 정의

* 신뢰성과 순차적인 전달을 할 수 있음
* 신뢰성 있는 바이트 스트림을 전송
* 소켓이라고 부르는 종단점을 생성함으로써 이루어짐
* 연결 설정은 3-way-handshake를 통해 이루어진다.
* 전이중 : 전송이 양방향으로 동시에 일어날 수 있음
* 점대점 : 각 연결이 정확히 2 개의 종단점을 가지고 있음

#### TCP handshake

![1553245800208](assets/1553245800208.png)

* 클라이언트 to 서버 서버 접속 요청인 syn(m)
* 서버 to 클라이언트 요청 수락 ack(m + 1), syn(n)
* 클라이언트 to 서버 ack(n + 1) 이 끝나면 연결 성립

![1553245860144](assets/1553245860144.png)

* 클라이언트 to 서버 연결 종료 요청 fin 플래그
* 서버 to 클라이언트 확인 메세지 ack
* 서버에서 데이터를 모두 보낼 때까지 Time out
* 데이터를 모두 보내고 통신이 끝나면 연결이 종료됐다고 서버 to 클라이언트 fin 플래그
* 클라이언트 to 서버 fin메세지 확인인 ack
* 클라이언트는 못 받은 데이터를 대비해 세션을 남겨놓고 time wait

#### 패킷 종류

두 종류인 이유는 요청과 응답에 대한 패킷을 주고 받아야 하기 때문

##### syn

* synchronize sequence number

##### ack

* acknowledgement

#### why 3 way?

* TCP는 양방향성이기 때문에 자신의 존재를 알리고 목소리가 들리는지 확인해야 한다.

#### why randomized sequence number?

* 포트는 범위가 한정적이고 재사용되기 때문에 과거의 사용했던 포트를 사용할 수 있다.
* 이 때, 순차적인 수가 전송된다면 이전의 연결에서 온 패킷으로 인식할 수 있다.

### UDP

#### 정의

* 비연결형 프로토콜
* IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법 제공
* 오류제어나 손상된 세그먼트에 대해 재전송을 하지 않는다
* TCP보다 적은 메시지가 요구됨

### HTTP/HTTPS

#### HTTP의 문제점

* 평문 통신이기 때문에 도청 가능
* 통신 상대를 확인하지 않기 때문에 위장 가능
* 완전성을 증명할 수 없기에 변조 가능

#### TCP/IP는 도청 가능한 네트워크

* 통신 경로 상에서 엿볼수 있다.
* 보안 방법
  * 통신 자체를 암호화
    * SSL or  TSL이라는 다른 프로토콜을 조합해서 통신 내용을 암호화
  * 콘텐츠를 암호화
    * 암호화해서 전송하면 받은 측에서는 암호를 해독하여 출력하는 처리가 필요

#### 위장 가능

* 상대가 누구인지 확인하는 처리가 없기 때문에 누구든 리퀘스트를 보내고 서버는 리스폰스를 반환한다.
  * 서버가 원래 의도한 리스폰스를 보내야 하는 서버인지 확인 불가
  * 리스폰스를 반환한 곳이 의도한 클라이언트인지 확인 불가
  * 상대가 접근이 허가된 상대인지를 알 수 없음
  * 의미 없는 리퀘스트도 수신 (DoS 공격 방지 불가)
* SSL로 상대를 확인한다.
* SSL
  * 상대를 확인하는 수단으로 증명서 제공
  * 신뢰할 수 있는 제 3자 기관에서 발행된 것이기 때문에 실재하는 사실을 증명
  * 통신하고 싶은 서버임을 확인하고 개인 정보 누설 위험성 줄어듬
  * 본인 확인과 웹 사이트 인증 가능

#### 변조 가능

* 정보가 정확한 지 알 수 없다.
* 통신 중간에 누군가에 의해 변조될 수 있다.
* MD5, SHA-1 등의 해쉬 값을 확인을 통해 방지 가능
* 그러나 HTTPS를 사용하는 것이 좋다 SSL에는 인증이나 암호화, 다이제스트 기능이 있다

#### HTTPS

* HTTP의 소켓 부분을 SSL(Secure Socket Layer)나 TLS(Transport Layer Security)라는 프로토콜로 대체
* HTTP가 SSL과 통신하고 SSL이 TCP와 통신
* 공통키 암호화 와 공개키 암호화
* 공통키는 공통키를 공개키 방식으로 교환하고 다음부터 통신은 공통키 암호를 사용

### DNS round robin

#### 문제점

* 서버의 수만큼 공인 IP 주소가 필요함 부하 분산을 위해 서버의 대수를 늘리려면 그만큼 공인 IP가 필요함
* 균등하게 분산되지 않음
  * 스마트폰 접속은 캐리어 게이트웨이라고 하는 프록시 서버 경유
  * 이 때 이름변환 결과가 캐싱되므로 항상 같은 서버로 접속
  * PC에서도 DNS 질의 결과를 캐싱하기 때문에 균등하게 부하분산이 안됨

#### 해결 방안

##### weighted round robin

* 각각의 웹 서버에 가중치를 가미해서 분산 비율을 변경 가중치가 큰 서버일 수록 빈번하게 선택되므로 처리능력이 높은 서버에 가중치를 높게 둔다

##### least-connection

* 접속 클라이언트 수가 가장 적은 서버를 선택, 로드 밸런서에서 실시간으로 커넥션 수를 관리하거나 각 서버에서 주기적으로 알려줘야 한다.

### 웹 통신의 큰 흐름

* 브라우저 -> 프로토콜 스택, LAN어댑터 -> 허브, 스위치, 라우터 -> 액세스 회선, 프로바이더 -> 방화벽, 캐시 서버 -> 웹 서버

##### 브라우저

* url에 입력된 값을 브라우저 규칙에 따라 의미 조사
* 의미에 따라 request 메시지 만들고 웹서버로 전송

##### 프로토콜 스택, LAN어댑터

* 프로토콜 스택(운영체제에 내장된 네트워크 제어용 소프트웨어)가 브라우저로부터 메시지를 받음
* 메시지를 패킷 속에 저장
* 수신처 주소 등의 제어정보를 덧붙임
* 패킷을 LAN어댑터에 넘긴다
* LAN어댑터는 패킷을 전기신호로 변환
* LAN 케이블에 송출

##### 허브, 스위치, 라우터

* LAN 어댑터가 송신한 패킷은 스위칭 허브를 경유해 인터넷 접속용 라우터에 도착
* 라우터는 패킷을 프로바이더(통신사)에게 전달
* 인터넷으로 접속

##### 액세스 회선, 프로바이더

* 패킷은 인터넷의 입구에 있는 액세스 회선(통신 회선)에 의해 통신사용 라우터(POP)까지 운반
* POP를 거쳐 인터넷의 핵심부로 들어감
* 수 많은 고속 라우터들 사이로 패킷이 목적지를 향해 흘러감

##### 방화벽, 캐시서버

* 패킷은 인터넷 핵심부를 통과하여 웹 서버 측의 LAN에 도착
* 기다리고 있던 방화벽이 도착한 패킷을 검사
* 패킷이 웹 서버까지 가야하는지 가지 않아도 되는지 판단하는 캐시서버가 있음
* 액세스한 페이지의 데이터가 캐시서버에 있으면 웹 서버에 의뢰하지 않고 바로 그 값을 전송

##### 웹 서버

* 패킷이 물리적인 웹 서버에 도착하면 웹 서버의 프로토콜 스택은 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘긴다

* 메시지를 받은 웹 서버 애플리케이션은 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 회송

* 왔던 방식대로 응답 메시지가 클라이언트에게 전달

  

### OSI 7계층

응용 -> 표현 -> 세션 -> 전송 -> 네트워크 -> 데이터 링크 -> 물리

#### 물리

* 전송에 필요한 두 장치 간의 실제 접소고가 절단 등 규칙 정의

#### 데이터 링크

* 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송
* 송신 측과 수신 측의 속도 차이를 해결하기 위한 흐름 제어
* 프레임의 시작과 끝을 구분하기 위해 프레임 동기화
* 오류의 검출과 회복을 위한 오류 제어
* 프레임의 순서적 전송을 위한 순서 제어

#### 네트워크

* 개방 시스템들 간의 네트워크 연결을 관리하고 데이터의 교환 및 중계
* 네트워크 연결을 설정 유지 해제
* 경로 설정(routing), 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송

#### 전송

* 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로 엔드 투 엔드 간에 투명한 데이터 전송을 가능케 함
* 하위 3계층과 상위 3계층의 인터페이스 담당
* 엔드 투 엔드 간의 전송 연결 설정, 데이터 전송, 연결 해제
* 주소 설정, 다중화, 오류 제어, 흐름 제어
* TCP, UDP

#### 세션

* 송 수신 측 간의 관련성을 유지하고 대화 제어를 담당
* 송 수신 측 간의 대화 동기를 위해 전송하는 정보의 일정한 부분에 체크점을 두어 정보의 수신 상태를 체크하고 체크점을 동기점이라 한다.
* 대화 구성 및 동기 제어, 데이터 교환 관리
* 동기점은 오류가 있는 데이터의 회복을 위해 사용

#### 표현

* 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환
* 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요함
* 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식 변환, 문맥 관리

#### 응용

* 사용자(응용 프로그램)가 osi 환경에 접근할 수 있도록 서비스를 제공
* 응용 프로세스 간의 정보 교환, 전자 사서함, 파일 전송, 가상 터미널 제공

### 주소 체계

* IP 32bit
* 8bit씩 나눈다
* A클래스.B클래스.C클래스.D클래스/E클래스
* 국가.중대형.소규모.멀티캐스트/실험적 주소

#### 서브네팅

* 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것

* 클래스마다 다르게 사용 기본값은 255.0.0.0 255.255.0.0 255.255.255.0

* 한 개의 C 클래스 주소를 나누어 사용하기 위해 호스트 주소를 8비트가 아닌 6비트만 사용하고, 네트워크 주소로 24비트가 아닌 26비트를 사용하면

  서브넷 마스크는 255.255.255.192가 된다.

  11111111.11111111.11111111.11000000

#### IPv6

* IPv4의 주소 부족 문제를 해결하기 위해 개발됨
* 16 비트씩 8부분 총 128비트로 구성됨

![1553274496555](C:\Users\gstjs\TIL\assets\1553274496555.png)

![1553274536667](C:\Users\gstjs\TIL\assets\1553274536667.png)

![1553274569272](C:\Users\gstjs\TIL\assets\1553274569272.png)

![1553274624849](C:\Users\gstjs\TIL\assets\1553274624849.png)

## 운영체제

### 프로세스와 스레드

#### 프로세스

* 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것
* 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받고 이를 총칭해서 프로세스라고 함
* 함수의 매개변수, 복귀 주소, 로컬 변수 같은 임시 자료를 갖는 프로세스 스택
* 전역 변수들을 수록하는 데이터 섹션을 포함
* 실행 중에 동적으로 할당되는 메모리인 힙을 포함

##### 프로세스 제어 블록(PCB)

* 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조
* 프로세스 생성과 동시에 고유한 PCB 생성
* 작업 도중 프로세스 전환이 발생하면 작업을 저장하고 CPU에 반환해야 하는데 진행 상황이 PCB에 저장됨
* 저장되는 정보
  * 프로세스 식별자(PID)
  * 프로세스 상태
  * 프로그램 카운터 : 다음 실행할 명령어의 주소
  * CPU 레지스터
  * CPU 스케쥴링 정보 : 프로세스의 우선수위, 스케줄 큐에 대한 포인터
  * 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블
  * 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록
  * 어카운팅 정보 : 사용된 CPU 시간, 시간 제한, 계정 번호

#### 스레드

* 프로세스의 실행 단위
* 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 고유 가능
* 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택으로 구성
* 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 열린 파일, 신호 같은 운영체제 자원 공유
* 하나의 프로세스를 다수의 실행단위로 구분하여 자원을 공유하고 자원의 생성과 관리 중복을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩이라 한다
* 멀티스레딩의 경우 독립적인 작업을 수행해야 하므로 각자의 스택과 PC 레지스터 값을 갖고 있다.

##### 스택을 스레드마다 독립적으로 할당하는 이유

* 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이다.
* 독립적인 실행 흐름을 추가하기 위해 독립된 스택을 할당

##### PC Register를 스레드마다 독립적으로 할당하는 이유

* PC 값은 스레드가 명령어의 어디까지 수행했는지를 나타낸다.
* 스레드는 CPU를 할당받았다가 스케줄러에 의해 뺏길 수 있기 때문에 어디까지 수행했는지 기억해야함
* 따라서 독립적으로 할당

#### 멀티 스레드

##### 장점

* 메모리 공간과 시스템 자원 소모가 줄어듦
* 스레드 간의 통신이 필요한 경우에도 전역 변수의 공간이나 Heap 영역을 이용해 통신 가능
* 스레드의 context switch는 캐시 메모리를 비울 필요가 없기 때문에 빠르다
* 자원소모가 줄어들어 응답시간이 단축됨

##### 문제점

* 멀티 프로세스 프로그램은 자원을 공유하지 않기 때문에 상관없지만 멀티 스레드는 공유하기 때문에 관리해줘야됨
* 동기화 작업을 해줘야 함 동기화를 통해 작업 처리 순서를 제어하고 자원 접근을 제어
* 병목현상이 발생해 성능 저하 가능성이 있음

### 스케쥴러

스케쥴링을 위한 Queue

* Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합
* Ready Queue : 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
* Device Queue : Device I/O 작업을 대기하고 있는 프로세스의 집합

#### 장기 스케줄러(or job scheduler)

* 메모리는 한정되어 있는데 많은  프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리에 임시로 저장됨, 이 풀에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 ready queue에 올릴 지 결정함

#### 단기 스케줄러(or CPU scheduler)

* CPU와 메모리 사이의 스케줄링을 담당
* Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 실행 시킬지 결정
* 프로세스에 CPU 할당

#### 중기 스케줄러(Swapper)

* 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄
* 프로세스에게서 memory를 deallocate
* degree of Multiprogramming 제어
* 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케쥴러

### CPU Scheduler

#### FCFS(First Come First Served)

* 먼저 온 고객을 먼저 처리
* 비 선점형 - cpu가 반환되면 스케줄링함
* 문제점 - 소요시간이 긴 프로세스가 먼저 도달하면 효율성을 낮춤

#### SJF(Short Job First)

* 다른 프로세스가 먼저 도착했어도 CPU 쓰는 시간이 짧은 프로세스에게 선 할당
* 비선점형 스케줄링
* 문제점 - 사용 시간이 긴 프로세스는 거의 영원히 CPU를 할당받을 수 없다.

#### SRT(Shortest Remaining time First)

* 새로운 프로세스가 올 때마다 새로운 스케줄링
* 선점형 스케줄링 - 현재 수행중인 프로세스의 남은 시간보다 짧은 시간을 가지는 새로운 프로세스가 도착하면 CPU 뺏김
* 문제점 - 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU 사용시간 측정 불가

#### Priority Scheduling

* 우선수위가 가장 높은 프로세스에게 CPU 할당
* 선점형 스케줄링 - 더 높은 우선순위의 프로세스가 도착하면 뺏김
* 비선점형 스케줄링 - 더 높은 우선순위의 프로세스가 오면 레디큐의 head에 넣음
* 문제점 - 무기한 봉쇄(실행 준비는 되었으나 CPU를 사용 못하는 프로세스를 CPU가 무기한 대기)
* 해결책 - 아무리 우선순위가 낮더라도 오래 기다리면 높여주자

#### Round Robin

* 현대적인 스케쥴링
* 각 프로세스는 동일한 크기의 할당 시간을 갖는다
* 할당시간이 지나면 프로세스는 선점당하고 레디큐의 제일 뒤에가서 줄선다
* CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
* 프로세스의 context를 저장할 수 있기 때문
* 장점 - 응답시간이 빨라짐
* 공정하다

### 동기와 비동기

#### 동기

* 동기는 빨래를 하고 설거지를 하고 청소를 함

#### 비동기

* 빨래는 빨래업체, 설거지는 설거지 업체, 청소는 청소업체
* 끝나면 나에게 알려줌 
* 백그라운드 스레드에서 해당 작업을 처리하는 경우가 비동기

### 메모리 관리 전략

#### 배경

* 각각의 프로세스는 독립된 메모리 공간을 갖는다.
* 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다.
* 운영체제만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약이 없다

##### Swapping

메모리의 관리를 위해 사용되는 기법 라운드 로빈 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치로 보내고 다른 프로세스의 메모리를 불러올 수 있다

메모리 공간이 부족할 때 진행된다.

##### 단편화(Fragmentation)

프로세스들이 메모리에 적재되고 제거되는 일이 반복되면 프로세스들이 차지하는 메모리 틈에 사용하지 못할 만큼의 자유공간이 늘어남 이를 단편화라 한다

* 외부 단편화 : 메모리 공간 중 사용하지 못하게 되는 일부분. RAM 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을 때 발생함
* 내부 단편화 : 프로세스가 사용하는 메모리 공간에 포함된 남는 부분, 메모리 분할 자유공간 중 프로세스가 일부를 남기면 이를 내부 단편화라 한다.

![1553250853955](assets/1553250853955.png)

![1553250867037](assets/1553250867037.png)

#### Paging

하나의 프로세스가 사용하는 메모리 공간이 연속되어야 한다는 제약을 없애는 메모리 관리 방법

물리 메모리는 Frame이라는 고정 크기로 분리되어 있고, 논리 메모리는 페이지라 불리는 고정 크기의 블록으로 분리

페이징 기법을 통해 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있음

하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어 관리되고(논리 메모리에서) 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping 되어 저장됨

단점 : 내부 단편화 문제의 비중이 늘어남

##### 페이징 기법 주소 변환

* 주소 형식에 따른 페이지 맵 테이블 구성

  * 가상주소는 페이지 번호를 나타내는 p와 페이지 내에서 실제 내용이 위치하고 있는 곳 까지의 거리를 나타내는 변위값 d로 구성된다.
  * 가상주소 형식 페이지 번호(p) | 변위값(d)
  * 실기억주소는 페이지 프레임 번호를 나타내는 p'와 페이지 프리엠 내에서 실제 참조하는 위치까지의 거리를 나타내는 변위값 d로 구성된다.
  * 실 기억주소 형식 페이지 프레임(p') | 변위값(d)
  * 페이지 맵 테이블은 사용자 페이지가 주기억장치에 존재하는지 여부를 나타내는 상태 비트와 주기억장치에 없을 때의 보조기억장치 주소를 나타내는 디스크 주소, 페이지가 주기억장치에 있을 때의 페이지 프레임 번호로 구성
  * 페이지 맵 테이블 디스크 주소 | 페이지 프레임 번호 | 상태 비트

* 주소 변환 순서

  * 가상 주소의 페이지 번호에 해당하는 페이지 프레임 번호와 가상주소의 변위값을 이용하여 실기억주소를 만든다.
  * 만들어진 실기억주소를 이용하여 주기억장치를 액세스한다.

* 물리 메모리를 사용할 때, 페이지를 고정크기의 프레임단위로 나눈다.

* 가상 메모리도 같은 프레임단위인 페이지로 나누어 프레임과 페이지를 대응하게 한다.

* 물리메모리(프레임)과 가상메모리(페이지)를 대응하기 위해 page mapping이 필요함 이를 위해 page table 설정해야함

  ![1553267383785](assets\1553267383785.png)

  ![1553267844826](assets\1553267844826.png)

* 페이지 디렉토리

  * 1024개의 디렉토리 엔트리로 구성된 데이터
  * 시스템 당 하나만 조내
  * 페이지 테이블의 첫 주소, 페이지 테이블의 포인터가 있음

* 페이지 테이블

  * 각각의 페이지 테이블은 1024개의 페이지 테이블 엔트리를 갖고 있음
  * 페이지 테이블의 엔트리는 페이지의 포인터를 가지고 있음

* 전체 페이지 엔트리수 1024 * 1024 = 1MB 각각 4kb 크기이므로 1mb * 4kb = 4Gb

* 페이징을 사용해 4GB 영역의 주소를 지정 가능

* 최상위 10비트는 페이지 디렉토리에서 몇 번째 엔트리를 사용할지 결정

* 다음 10비트는 페이지 테이블에서 몇 번째 엔트리를 사용할 지 나타냄

* 하위 12비트는 4kb 물리 페이지상에서 오프셋을 나타냄

* 예제

* 어떤 컴퓨터는 사용자에게 2^32 바이트 크기의 가상 메모리 공간을 제공해준다. 컴퓨터는 2^18 바이트 크기의 실제 메모리 공간을 가진다. 가상메모리는 페이징에 의해 구현되고 페이지 크기는 4kb(2^12)이다. 사용자 프로세스는 가상주소 0x11123456을 생성한다. 시스템이 이 가상주소에 해당하는 실제 주소를 찾는 방법은?

* 2^32 바이트 크기의 가상 메모리 공간을 제공해줌으로 32bit 프로세서임을 알 수 있다. 페이지 크기는 4096 = 2 ^ 12 이고 4kb이다. 변위는 12bit이다. 논리 주소는 20비트와 12비트로 나눌 수 있다. 그래서 20비트는 페이제 테이블에 접근해서 프레임 번호를 알 수 있다. 거기에 오프셋 12bit를 더해준다.

* ![1553271416251](assets\1553271416251.png)

  

### 가상 메모리

실행되는 코드의 전부를 물리 메모리에 존재 시켜야 했고, 메모리 용량보다 큰 프로그램은 실행할 수 없었다. 그래서 프로그램의 일부분만 메모리에 올릴 수 있다면 해서 나온 개념

#### 하는 일

작은 메모리를 가지고 큰 가상 주소 공간을 프로그래머에게 제공 가능

##### 가상 주소 공간

* 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간
* 프로세스가 요구하지 않는 메모리 공간은 실제 물리 메모리에 올리지 않으므로 절약 가능

##### 프로세스 간의 페이지 공유

* 시스템 라이브러리가 여러 프로세스들 사이에 공유될 수 있도록 한다.
* 프로세스들이 메모리를 공유하게 하고 공유 메모리를 통해 통신 가능
* 프로세스들은 자신의 주소 공간인줄 알지만 실제로는 공유 중임
* fork를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능케함

#### 요구 페이징

프로그램을 가상메모리에서 페이지로 관리하고 실행에 필요할 때만 물리 메모리에 적재된다.

프로세스 내의 개별 페이지들은 페이저(pager)에 의해 관리된다. 사용되지 않을 페이지를 가져오는 시간 낭비와 메모리 낭비를 줄일 수 있다.

##### Page Fault

프로세스의 동작에 필요한 페이지를 요청하는 과정에서 page fault가 발생하면 원하는 페이지를 보조저장장치에서 가져온다. 물리 메모리가 모두 사용중이라면 페이지 교체가 이뤄져야 한다.

* 디스크에서 필요한 페이지의 위치를 찾는다.
* 빈 페이지 프레임을 찾는다.
  * 페이지 교체 알고리즘을 통해 희생될 페이지를 고른다.
  * 희생될 페이지를 디스크에 기록하고 관련 페이지 테이블을 수정한다.
* 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정
* 사용자 프로세스 재시작

#### 페이지 교체 알고리즘

##### FIFO 페이지 교체

먼저 메모리에 올라온 순서대로 교체

활발히 사용되는 페이지를 교체해서 page fault를 늘릴 수도 있다.

##### 최적 페이지 교체

앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체

알고리즘 중 가장 낮은 페이지 부재율을 보장하지만 구현의 어려움이 있다.

각 페이지의 호출 순서와 참조 상황을 미리 예측해야 하므로 실현 가능성 희박

##### LRU (Least - Recently - Used)

가장 오랫동안 사용되지 않은 페이지를 교체

##### LFU(Least Frequently Used)

참조 횟수가 가장 적은 페이지를 교체

어떤 프로세스가 특정 페이지를 집중적으로 사용하다 다른 기능을 사용하게 되면 더 이상 사용하지 않아도 계속 있을 수 있음

##### MFU(Most Frequently Used)

참조 횟수가 가장 적은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반

### 보안 기법

#### 비밀키 시스템

* 동일한 키로 데이터를 암호화하고, 해독하는 대칭 암호화 기법
* 해독키를 아는 사람은 누구든지 암호문을 해독 가능하므로 해독키의 비밀성을 유지해야함
* 사용자의 증가에 따라 관리해야 할 키의 수가 상대적으로 많아지고 키의 분배가 어려움

#### 공용키 시스템(공개키 시스템)

* 서로 다른 키로 데이터를 암호화하고 해독하는 비대칭 암호화 기법
* 암호키는 공개하고 해독키는 비밀로 함으로써 누구나 암호문을 만들어 송신 또는 저장할 수 있으나 해독키를 가진 사람만이 해독할 수 있따.
* 키의 분배가 용이하고 관리해야할 키의 개수가 적다.
* 공용키 암호화의 대표적인 방식으로는 RSA가 있다.

### UNIX

#### 시스템 구성

* 하드웨어 - 커널 - 쉘 - 유틸리티 - 사용자

##### 커널

* UNIX의 가장 핵심적인 부분
* 주기억장치에 상주하며 실행됨
* 하드웨어를 보호하고 프로그램과 하드웨어 간 인터페이스 역할 담당
* 프로세스(스케줄링) 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등을 수행

##### 쉘

* 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기
* 파이프라인 기능을 지원하고 입,출력 재지정을 통해 출력과 입력의 방향을 변경 가능

##### 유틸리티

* 일반 사용자가 작성한 응용프로그램을 처리하는 데 사용
* 유틸리티 프로그램에는 에디터, 컴파일러, 인터프리터, 디버거 등이 있다

### 명령어

* fork 새로운 프로세스를 생성 하위 프로세스 호출, 프로세스 복제 명령
* exec 새로운 프로세스를 수행
* exit  프로세스 수행 종료